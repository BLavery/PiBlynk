/* Copyright (c) 2015 Volodymyr Shymanskyy. See the file LICENSE for copying permission. */

'use strict';

var events = require('events');
var util = require('util');
var path = require('path');

var default_certs_path = path.join(__dirname, "certs");

/*
* TCP Client
*/


exports.TcpClient = function(options) {
  var self = this;
  events.EventEmitter.call(this);

  var options = options || {};
  self.addr = options.addr || "blynk-cloud.com";
  self.port = options.port || 8442;

  var net = require('net');

  this.write = function(data) {
    if (self.sock) {
      self.sock.write(data, 'binary');
    }
  };

  this.connect = function(done) {
    if (self.sock) {  
      self.disconnect();
    }
    console.log("Connecting to TCP", self.addr, self.port);
    self.sock = new net.Socket();
    self.sock.setNoDelay(true);
    self.sock.setEncoding('binary');
    self.sock.connect({
      host: self.addr,
      family: 4,
      port: self.port
    }, function() {
      console.log('Connected');
      self.sock.on('data', function(data) {
        self.emit('data', data);
      });
      self.sock.on('end', function(data) {
        self.emit('end', data);
      });
      done();
    });
    self.sock.on('error', function(err) {
        self.emit('error', err);
    });

  };

  this.disconnect = function() {
    if (self.sock) {
      self.sock.destroy();
      self.sock.removeAllListeners();
      self.sock = null;
    }
  };
};

util.inherits(exports.TcpClient, events.EventEmitter);


/*
* SSL Client
*/

exports.SslClient = function(options) {
  var self = this;
  events.EventEmitter.call(this);
  
  var options = options || {};
  var certs_path = options.certs_path || default_certs_path;
  self.addr = options.addr || "blynk-cloud.com";
  self.port = options.port || 8441;
  // These are necessary only if using the client certificate authentication
  self.key  = options.key  || null;
  self.cert = options.cert || null;
  self.pass = options.pass || null;
  // This is necessary only if the server uses the self-signed certificate
  self.ca   = options.ca   || [ path.join(certs_path, 'server.crt') ];
  self.servername = options.servername || self.addr;

  var net = require('net');
  var tls = require('tls');
  var fs = require('fs');

  this.write = function(data) {
    if (self.sock) {
      self.sock.write(data, 'binary');
    }
  };

  this.connect = function(done) {
		
    if (self.sock) {
      self.disconnect();
    }

    var opts = {
      host: self.addr,
      port: self.port,
      servername: self.servername,
      rejectUnauthorized: false,
      family: 4
    };
    if (self.key) { 
      if (Buffer.isBuffer(self.key)) {
        opts.key = self.key;
      } else {
        opts.key = fs.readFileSync(self.key); 
      }
    }
    if (self.cert) { 
      if (Buffer.isBuffer(self.cert)) {
        opts.cert = self.cert;
      } else {
        opts.cert = fs.readFileSync(self.cert); 
      }
    }
    if (self.pass) { opts.passphrase = self.pass; }
    if (self.ca)   {
      if (Buffer.isBuffer(options.ca)) {
        opts.ca = options.ca;
      } else {
        opts.ca = self.ca.map(function(item){
          return fs.readFileSync(item);
        });
      }
    }

    console.log("Connecting to:", self.addr, self.port);
    var sock = new net.Socket();
    sock.on('error', function(e) {
      //////////////////////console.log(e)
    });
    sock.connect({
      host: self.addr,
      family: 4,
      port: self.port
    }, function() {
      console.log("SSL authorization...");
      opts.socket = sock;
      self.sock = tls.connect(opts, function() {
        if (!self.sock.authorized) {
          console.log('SSL not authorized');
          return;
        }
        console.log('Connected');
        self.sock.setNoDelay(true);
        self.sock.setEncoding('binary');
        self.sock.on('data', function(data) {
          self.emit('data', data);
        });
        self.sock.on('end', function(data) {
          self.emit('end', data);
        });
        
        done();
      });

      self.sock.on('error', function(err) {
          self.emit('error', err);
      });
    });
  };

  this.disconnect = function() {
    if (self.sock) {
      self.sock.destroy();
      self.sock.removeAllListeners();
      self.sock = null;
      
    }
  };
};

util.inherits(exports.SslClient, events.EventEmitter);

