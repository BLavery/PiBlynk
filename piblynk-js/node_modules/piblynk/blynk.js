/* Original:   
   Copyright (c) 2015 Volodymyr Shymanskyy. See the file LICENSE for copying permission. 
   https://github.com/vshymanskyy/blynk-library-js   */

/* This derived version:
   Brian Lavery May 2017   */

'use strict';


function string_of_enum(e,value) 
{
  for (var k in e) if (e[k] == value) return k;
  return "Unknown(" + value + ")";
}


function blynkHeader(msg_type, msg_id, msg_len) {
  return String.fromCharCode(
    msg_type,
    msg_id  >> 8, msg_id  & 0xFF,
    msg_len >> 8, msg_len & 0xFF
  );
}

var MsgType = {
  RSP           :  0,
  REGISTER      :  1, 
  LOGIN         :  2,
  SAVE_PROF     :  3,
  LOAD_PROF     :  4,
  GET_TOKEN     :  5,
  PING          :  6,
  ACTIVATE      :  7,
  DEACTIVATE    :  8, 
  REFRESH       :  9,
  TWEET         :  12,
  EMAIL         :  13,
  NOTIFY        :  14,
  BRIDGE        :  15,
  HW_SYNC       :  16,
  INTERNAL      :  17,
  SMS           :  18,
  PROPERTY      :  19,
  HW            :  20,

  REDIRECT      :  41,
  DEBUG_PRINT   :  55
};

var MsgStatus = {
  OK                    :  200,
  ILLEGAL_COMMAND       :  2,
  ALREADY_REGISTERED    :  4,
  INVALID_TOKEN         :  9
};

var BlynkState = {
  CONNECTING    :  1,
  CONNECTED     :  2,
  DISCONNECTED  :  3
};

var bl_node = require('./blynk-node.js');
var events = require('events');
var util = require('util');
  
Math.radians = function(degrees) {
  return degrees * Math.PI / 180;
};
Math.degrees = function(radians) {
  return 180 * radians / Math.PI ;    
};

var GPIO_OnOff = function() {
    // A MINIMAL gpio functionality for plain IN or OUT. 
    // GPIO Output becomes an output at first write() from APP.
    // GPIO Input has no facility for internal pullup/pulldown resistor.
    // Within these limits, APP programming to "gpio pins" requires no user programming at RPi script.
    // For further gpio requirements, use "virtual pins" and code custom handlers,
    //     eg with onoff or rpio or pigpio modules.
    
  var self = this;
  var Gpio;

  Gpio = require('onoff').Gpio;
  this.init = function(blynk) {
    self.blynk = blynk;
  };
  this.process = function(values) {
    switch(values[0]) {
      case 'pm':
        //self.blynk.emit('pm', values); 
        break;
      case 'dw':
        var pin = new Gpio(parseInt(values[1]), 'out');
        pin.write(parseInt(values[2]));
        break;
      case 'dr':
        var pin = new Gpio(values[1], 'in');
        pin.read(function(err, value) {
          if (!err) {
            self.blynk.sendMsg(MsgType.HW, ['dw', values[1], value]);
          }
        });
        break;
      case 'ar':  // no analog on RPi !
      case 'aw':
        break;
      default:
        return false;
    }
    return true;
  };
};



/*
 * Blynk
 */

var Blynk = function(auth, options) {
  var self = this;

  events.EventEmitter.call(this);
  this.auth = auth;
  var options = options || {};
  this.heartbeat = options.heartbeat || (10*1000);

  this.board = new GPIO_OnOff();
  self.board.init(self);

  // Auto-detect connector  -  ssl default
  if (options.connector) {
    this.conn = options.connector;
  } else {
    this.conn = new bl_node.SslClient(options);
  }

  this.timerRecon = null; 
  
  this.buff_in = '';
  this.msg_id = 1;
  this.vpins = [];

  this.VirtualPin = function(vPin) {

    events.EventEmitter.call(this);

    this.pin = vPin;
    self.vpins[vPin] = this;

    this.write = function(value) {
      self.virtualWrite(this.pin, value);
    };
    this.setProperty = function(property, value) {
      self.setProperty(this.pin, property, value);
    };
  };

  this.WidgetBridge = function(vPin) {
    this.pin = vPin;
    events.EventEmitter.call(this);

    this.setAuthToken = function(token) {
      self.sendMsg(MsgType.BRIDGE, [this.pin, 'i', token]);
    };
    this.digitalWrite = function(pin, val) {
      self.sendMsg(MsgType.BRIDGE, [this.pin, 'dw', pin, val]);
    };
    this.analogWrite = function(pin, val) {
      self.sendMsg(MsgType.BRIDGE, [this.pin, 'aw', pin, val]);
    };
    this.virtualWrite = function(pin, val) {
      self.sendMsg(MsgType.BRIDGE, [this.pin, 'vw', pin].concat(val));
    };
  };

  this.WidgetTerminal = function(vPin) {
    // seems identical to VirtualPin
    events.EventEmitter.call(this);
    this.pin = vPin;
    self.vpins[vPin] = this;

    this.write = function(data) {
      self.virtualWrite(this.pin, data);
    };
  };

  this.WidgetSensor = function(vPin) {
    this.vpin = new self.VirtualPin(vPin);
    this.value = 0;
    var me = this;
    this.timestamp = new Date();   
    this.vpin.on("write", function(param) { 
        me.value = param[0];
        me.timestamp = new Date();
    });
    this.age = function() {  // age of data in seconds
        return Math.round(((new Date()) - this.timestamp)/1000);
    };
  };

  this.WidgetAccel = function(vPin) {
    this.vpin = new self.VirtualPin(vPin);
    this.X = 0;
    this.Y = 0;
    this.Z = 0;
    var me = this;
    this.timestamp = new Date();   
    this.vpin.on("write", function(param) { 
        me.X = param[0];
        me.Y = param[1];
        me.Z = param[2];
        me.timestamp = new Date();
    });
    this.roll = function() {
        return Math.round(57.3*Math.atan2(-this.X, this.Z));
    };
    this.pitch = function() {
        return Math.round(57.3*Math.atan2(this.Y, this.Z));
    };
    this.age = function() {  // age of data in seconds
        return Math.round(((new Date()) - this.timestamp)/1000);
    };
  };

  this.WidgetGPS = function(vPin) {
    this.vpin = new self.VirtualPin(vPin);
    this._lat0 = 0;
    this._lon0 = 0;
    this.latitude = 0;
    this.longtitude = 0;
    var me = this;
    this.timestamp = new Date();   
    this.vpin.on("write", function(param) { 
        me.latitude = param[0];
        me.longtitude = param[1];
        me.timestamp = new Date();
        if(me._lat0 == 0) {
            me._lat0 = me.latitude;
            me._lon0 = me.longtitude;
        }
    });
    
    this.getDistanceFromLatLonInM = function(lat1,lon1,lat2,lon2) {
      var R = 6371; // Radius of the earth in km
      var dLat = Math.radians(lat2-lat1); 
      var dLon = Math.radians(lon2-lon1); 
      var a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(Math.radians(lat1)) * Math.cos(Math.radians(lat2)) * 
        Math.sin(dLon/2) * Math.sin(dLon/2)
        ; 
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
      return  1000* R * c; // Distance in m
      // http://stackoverflow.com/questions/18883601/function-to-calculate-distance-between-two-coordinates-shows-wrong
    }

    this.getBearing = function(lat1,lng1,lat2,lng2) {
        var dLon = Math.radians(lng2-lng1);
        var y = Math.sin(dLon) * Math.cos(Math.radians(lat2));
        var x = Math.cos(Math.radians(lat1))*Math.sin(Math.radians(lat2)) - Math.sin(Math.radians(lat1))*Math.cos(Math.radians(lat2))*Math.cos(dLon);
        var brng = Math.degrees(Math.atan2(y, x));
        return ((brng + 360) % 360);
        //http://stackoverflow.com/questions/11415106/issue-with-calcuating-compass-bearing-between-two-gps-coordinates
    };
 
    this.distance = function() { 
        return this.getDistanceFromLatLonInM(me._lat0,me._lon0,me.latitude,me.longtitude);
    };
    this.direction = function() { 
        return this.getBearing(me._lat0,me._lon0,me.latitude,me.longtitude);
    };
    this.age = function() {  // age of data in seconds
        return Math.round(((new Date()) - this.timestamp)/1000);
    };
    this.reset = function() {
            me._lat0 = me.latitude;
            me._lon0 = me.longtitude;
    };
  };

  this.WidgetLCD = function(vPin) {
    this.pin = vPin;

    this.clear = function() {
      self.virtualWrite(this.pin, 'clr');
    };
    this.print = function(x, y, val) {
      self.sendMsg(MsgType.HW, ['vw', this.pin, 'p', x, y, val]);
    };
  };

  this.WidgetLED = function(vPin) {
    this.pin = vPin;

    this.setValue = function(val) {
      self.virtualWrite(this.pin, val);
    };
    this.setColour = function(val) {
      self.setProperty(this.pin, "color", val);
    };
    this.turnOn = function() {
      self.virtualWrite(this.pin, 255);
    };
    this.turnOff = function() {
      self.virtualWrite(this.pin, 0);
    };
  };
  
  // function to disconnect when server down
    this.netDown = false; 
    this.lastGoodPing = null;
    setInterval(function(){
        var tlp = new Date() - self.lastGoodPing; // msec since last
        if (tlp > self.heartbeat*1.5 && !self.netDown) {
            // 1.5 ping-times without reply
            self.netDown = true;
            //console.log("Net Down");
            //self.emit("network", "Down");
            self.disconnect();   /////////////////////////////////////////
        }
        else if(tlp<=self.heartbeat*1.2 && self.netDown) {
            //pings to server are being replied again
            self.netDown = false;
            //console.log("Net Up");
            //self.emit("network", "Up");
        }
    }, 5000);

    util.inherits(this.VirtualPin, events.EventEmitter);
    util.inherits(this.WidgetBridge, events.EventEmitter);
    util.inherits(this.WidgetTerminal, events.EventEmitter);


  if (!options.skip_connect) {
    this.connect();
  }
};

util.inherits(Blynk, events.EventEmitter);


Blynk.prototype.onReceive = function(data) {
  var self = this;
  self.buff_in += data;
  while (self.buff_in.length >= 5) {
    var msg_type = self.buff_in.charCodeAt(0);
    var msg_id   = self.buff_in.charCodeAt(1) << 8 | self.buff_in.charCodeAt(2);
    var msg_len  = self.buff_in.charCodeAt(3) << 8 | self.buff_in.charCodeAt(4);

    if (msg_id === 0)  { 
		//console.log("id=0 error"); 
		//return self.disconnect();    
		// https://github.com/blynkkk/blynkkk.github.io/blob/master/BlynkProtocol.md
		// ... advises disconnect() or stop for id==0 
		// This appears empirically to be unnecessary. We choose to ignore.
		}
    if (msg_type === MsgType.RSP) { 
		self.lastGoodPing = new Date();

        if (self.timerConn && msg_id === 1) {
          if (msg_len === MsgStatus.OK || msg_len === MsgStatus.ALREADY_REGISTERED) {
            clearInterval(self.timerConn);
            self.timerConn = null;                  
            if (this.timerHb) {    clearInterval(this.timerHb); };
            self.timerHb = setInterval(function() {
              self.sendMsg(MsgType.PING);
            }, self.heartbeat);
            console.log('Authorized');
            self.sendMsg(MsgType.INTERNAL, ['ver', '0.4.7', 'dev', 'js']); 
            self.emit('connect');
          } else {
            console.log('Could not login:', string_of_enum(MsgStatus, msg_len));
            //if invalid token, no point in trying to reconnect
            if (msg_len === MsgStatus.INVALID_TOKEN) {
              //letting main app know why we failed
              console.log(33);  /////////////////
              self.emit('error', string_of_enum(MsgStatus, msg_len));
              self.disconnect();
              if(self.timerConn) {
                clearInterval(self.timerConn);
                self.timerConn = null;
              }
            }
          }
        }

      self.buff_in = self.buff_in.substr(5);
      continue;
    }


    // non-RSP
    if (msg_len > 1024)  {  return self.disconnect(); }
    if (self.buff_in.length < msg_len+5) {
      return;
    }
    var values = self.buff_in.substr(5, msg_len).split('\0');
    self.buff_in = self.buff_in.substr(msg_len+5);

    if (msg_type === MsgType.LOGIN ||
        msg_type === MsgType.PING)
    {
      self.sendRsp(MsgType.RSP, msg_id, MsgStatus.OK);
    } else if (msg_type === MsgType.GET_TOKEN) {
      self.sendRsp(MsgType.GET_TOKEN, msg_id, self.auth.length, self.auth);
    } else if (msg_type === MsgType.LOAD_PROF) {
        console.log("Profile req??"); //??
        //self.sendRsp(MsgType.LOAD_PROF, msg_id, self.profile.length, self.profile);
    } else if (msg_type === MsgType.HW ||
               msg_type === MsgType.BRIDGE)
    {
      if (values[0] === 'vw') {
        var pin = parseInt(values[1]);
        if (self.vpins[pin]) {
          self.vpins[pin].emit('write', values.slice(2));
        }
      } else if (values[0] === 'vr') {
        var pin = parseInt(values[1]);
        if (self.vpins[pin]) {
          self.vpins[pin].emit('read');
        }
      } else if (self.board.process(values)) {

      } else {
        console.log('Invalid cmd: ', values[0]);
      }
    } else if (msg_type === MsgType.REDIRECT) {
      self.conn.addr = values[0];
      if (values[1]) {
        self.conn.port = parseInt(values[1]);
      }
      console.log('Redirecting to ', self.conn.addr, ':', self.conn.port);
      self.disconnect();
    } else if (msg_type === MsgType.DEBUG_PRINT) {
      console.log('Server: ', values[0]);
    } else if (msg_type === MsgType.REGISTER ||
               msg_type === MsgType.SAVE_PROF ||
               msg_type === MsgType.INTERNAL ||
               msg_type === MsgType.ACTIVATE ||
               msg_type === MsgType.DEACTIVATE ||
               msg_type === MsgType.REFRESH)
    {
      // these make no sence...
    } else {
      console.log('Invalid msg type: ', msg_type);
      self.sendRsp(MsgType.RSP, msg_id, MsgStatus.ILLEGAL_COMMAND);
    }
  } // end while
};

Blynk.prototype.sendRsp = function(msg_type, msg_id, msg_len, data) {
  var self = this;
  data = data || "";
  msg_id = msg_id || (self.msg_id++);
  if (msg_type == MsgType.RSP) {
    data = blynkHeader(msg_type, msg_id, msg_len);
  } else {
    data = blynkHeader(msg_type, msg_id, msg_len) + data;
  }
  self.conn.write(data)
};

Blynk.prototype.sendMsg = function(msg_type, values, msg_id) {
  var values = values || [''];
  var data = values.join('\0');    
  if ((typeof this.timerHb) === 'object' && this.timerHb != null) {
      this.sendRsp(msg_type, msg_id, data.length, data);  
      }; 
};

/*
  * API
  */

Blynk.prototype.connect = function() {
  var self = this;

  var doConnect = function() {
    if(self.conn) {
      //cleanup events
      self.conn.removeAllListeners();
    }
    self.conn.connect(function() {
      self.conn.on('data', function(data) { self.onReceive(data);     });
      self.conn.on('end',  function()     { self.end();               });

      self.sendRsp(MsgType.LOGIN, 1, self.auth.length, self.auth);
    });
    self.conn.on('error', function(err) { self.error(err);            });
  };


	if (self.timerConn) clearInterval(self.timerConn);  
    self.timerConn = setInterval(
    doConnect, 12000); 
    doConnect();  

};

Blynk.prototype.disconnect = function(reconnect) {
  console.log('Disconnect blynk');
  if(typeof reconnect === 'undefined' ) {
    reconnect = true;
  }

  var self = this;
  this.buff_in = "";  // dump any received & unprocessed data 
  this.conn.disconnect();
  if (this.timerHb) {
    clearInterval(this.timerHb);
    this.timerHb = null;
  }
  this.emit('disconnect');
  //cleanup to avoid multiplying listeners
  this.conn.removeAllListeners();

  //starting reconnect procedure if not already in connecting loop and reconnect is true
  if(reconnect && !self.timerConn) {
    clearTimeout(this.timerRecon); 
    this.timerRecon = setTimeout(function () {
		self.connect()}, 5000); 
  }
};

Blynk.prototype.error = function(err) {
  var self = this;
  //if we throw error and user doesn't handle it, app crashes. is it worth it?
  if(err.code == "ECONNRESET")
	 self.disconnect(); 
  else
	  this.emit('error', err.code?err.code:'ERROR');
  console.error('Error:::', err.code);
  //starting reconnect procedure if not already in connecting loop
  if(!self.timerConn) {
      clearTimeout(this.timerRecon); 
      this.timerRecon = setTimeout(function () {
		  self.connect()}, 6000);
  }
};

Blynk.prototype.end = function() {
  var self = this;         
  self.disconnect();
};


Blynk.prototype.virtualWrite = function(pin, val) {  
  this.sendMsg(MsgType.HW, ['vw', pin].concat(val));
};

Blynk.prototype.setProperty = function(pin, prop, val) {
  this.sendMsg(MsgType.PROPERTY, [pin, prop].concat(val));
};


Blynk.prototype.syncAll = function() {
  this.sendMsg(MsgType.HW_SYNC);
};

Blynk.prototype.syncVirtual = function(pin) {
  this.sendMsg(MsgType.HW_SYNC, ['vr', pin]);
};


Blynk.prototype.email = function(to, topic, message) {
  this.sendMsg(MsgType.EMAIL, [to, topic, message]);
};

Blynk.prototype.notify = function(message) {
  this.sendMsg(MsgType.NOTIFY, [message]);
};

Blynk.prototype.tweet = function(message) {
  this.sendMsg(MsgType.TWEET, [message]);
};

Blynk.prototype.sms = function(message) {
  this.sendMsg(MsgType.SMS, [message]);
};

if (typeof module !== 'undefined' && ('exports' in module)) {
  exports.Blynk = Blynk;
  exports.TcpClient = bl_node.TcpClient;
  exports.SslClient = bl_node.SslClient;
}




